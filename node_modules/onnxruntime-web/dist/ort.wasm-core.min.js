/*!
* ONNX Runtime Web v1.16.0-dev.20230704-d540c7da0f
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ort=t():e.ort=t()}(self,(()=>{return e={2818:(e,t,n)=>{"use strict";t.c8=t.rX=void 0;const r=n(2235),a=n(5381),o=n(9544),i=n(6640);t.rX=()=>{if(("number"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),"boolean"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),"boolean"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),"number"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const e="undefined"==typeof navigator?(0,a.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,o.initializeWebAssemblyInstance)()}async createSessionHandler(e,t){const n=new i.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(e,t),Promise.resolve(n)}}},1057:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),a(n(2235),t);const o=n(2235),i=n(8408);{const e=n(2818).c8;(0,o.registerBackend)("cpu",e,10),(0,o.registerBackend)("wasm",e,10),(0,o.registerBackend)("xnnpack",e,9),(0,o.registerBackend)("webnn",e,9)}o.env.versions.web=i.version},8408:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.version=void 0,t.version="1.16.0-dev.20230704-d540c7da0f"},3838:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGpuBackend=void 0;const r=n(4955),a=n(7771),o=n(8510),i=n(8305);t.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const n={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize}};t.features.has("timestamp-query-inside-passes")&&"default"===e.webgpu.profilingMode&&(this.profilingEnabled=!0,n.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await t.requestDevice(n),this.gpuDataManager=(0,a.createGpuDataManager)(this),this.programManager=new i.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,(0,r.configureLogger)(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(e,t,n,a,o){if(t.length!==e.inputTypes.length)throw new Error(`Input size must be equal to ${e.inputTypes.length}.`);const i=[];for(let e=0;e<t.length;++e){const n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);i[e]=n}const s=((e,t,n)=>{const r=t.map((e=>`${e.join(",")}`)).join("_"),a=n.join("_");let o=e.name;return e.cacheHint&&(o+="["+e.cacheHint+"]"),o+=":"+r+";"+a,o})(e,t.map((e=>e.dims)),i.map((e=>e.type)));let u=this.programManager.getArtifact(s);const l=u?u.programInfo:"function"==typeof e.get?e.get():e,c=0===n.length?l.outputs.map(((e,t)=>t)):n;if(c.length!==l.outputs.length)throw new Error(`Output size ${c.length} must be equal to ${l.outputs.length}.`);const d=[],p=[];for(let e=0;e<l.outputs.length;++e){if(!Number.isInteger(c[e])||c[e]<-2||c[e]>=l.outputs.length)throw new Error(`Invalid output index: ${c[e]}`);const t=-1===c[e],n=-2===c[e],r=t||n?o(l.outputs[e].dataType,l.outputs[e].dims):a(c[e],l.outputs[e].dataType,l.outputs[e].dims),i=this.gpuDataManager.get(r.data);if(!i)throw new Error(`no GPU data for output: ${r.data}`);if(t&&this.temporaryData.push(i),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(i)}d.push(r),p.push(i)}const f=this.programManager.normalizeDispatchGroupSize(l.dispatchGroup(t));return u||(u=this.programManager.build(l,f),this.programManager.setArtifact(s,u)),(0,r.LOG_DEBUG)("info",(()=>`[ProgramManager] run "${l.name}" (key=${s}) with ${f[0]}x${f[1]}x${f[2]}`)),this.programManager.run(u,i,p,f),d}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){const n=await this.gpuDataManager.download(e),r=t();r.set(new Uint8Array(n,0,r.byteLength))}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n){const r=o.WEBGPU_OP_RESOLVE_RULES.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r[0],[r[1],n]])}releaseKernel(e){const t=this.kernelPersistentData.get(e);if(t){for(const e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t){const n=this.kernels.get(e);if(!n)throw new Error(`kernel not created: ${e}`);const[a,o,i]=n;if(null!==this.currentKernelId)throw new Error(`kernel "${a}" is not allowed to be called recursively`);this.currentKernelId=e,i[0]&&(i[1]=i[0](i[1]),i[0]=void 0),(0,r.LOG_DEBUG)("info",(()=>`[WebGPU] Start to run kernel "${a}"...`)),this.temporaryData=[];try{return o(t,i[1]),0}catch(e){return(0,r.LOG_DEBUG)("warning",`[WebGPU] Kernel "${a}" failed. Error: ${e}`),1}finally{for(const e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.init=void 0;const r=n(7917),a=n(3838),o=n(4955),i=n(6952);class s{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");const e=i.ShapeUtil.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");const e=i.ShapeUtil.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(i.ShapeUtil.size(e)!==i.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new s(this.module,this.dataType,this.data,e)}}class u{get customData(){return this.backend.currentKernelCustomData}constructor(e,t,n){this.module=e,this.backend=t;const r=e.HEAPU32;let a=n>>2;this.opKernelContext=r[a++];const o=r[a++],i=[];for(let t=0;t<o;t++){const t=r[a++],n=r[a++],o=r[a++],u=[];for(let e=0;e<o;e++)u.push(r[a++]);i.push(new s(e,t,n,u))}this.inputs=i}compute(e,t){var n,a,o;const u=null!==(a=null===(n=null==t?void 0:t.inputs)||void 0===n?void 0:n.map((e=>"number"==typeof e?this.inputs[e]:e)))&&void 0!==a?a:this.inputs,l=null!==(o=null==t?void 0:t.outputs)&&void 0!==o?o:[];return this.backend.run(e,u,l,((e,t,n)=>new s(this.module,t,this.output(e,n),n)),((e,t)=>{const n=(0,r.getTensorElementSize)(e);if(!n)throw new Error(`Unsupported data type: ${e}`);const a=n*i.ShapeUtil.size(t);return new s(this.module,e,this.backend.gpuDataManager.create(a).id,t)}))}output(e,t){const n=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+t.length));let r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}finally{this.module.stackRestore(n)}}}t.init=async(e,t)=>{const n=e.jsepInit;if(n&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");const r=new a.WebGpuBackend;await r.initialize(t),n({backend:r},(e=>r.alloc(e)),(e=>r.free(e)),((t,n,a,i=!1)=>{if(i)(0,o.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${a}`)),r.memcpy(t,n);else{(0,o.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${a}`));const i=e.HEAPU8.subarray(t,t+a);r.upload(n,i)}}),(async(t,n,a)=>{(0,o.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${a}`)),await r.download(t,(()=>e.HEAPU8.subarray(n,n+a)))}),((e,t,n)=>r.createKernel(e,t,n)),(e=>r.releaseKernel(e)),((t,n)=>{(0,o.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepRun: kernel=${t}, contextDataOffset=${n}`));const a=new u(e,r,n);return r.computeKernel(t,a)}))}}},4955:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LOG_DEBUG=t.LOG=t.configureLogger=void 0;const r=n(7917),a=["V","I","W","E","F"];let o,i;t.configureLogger=(e,t)=>{o=e,i=t},t.LOG=(e,t)=>{const n=(0,r.logLevelStringToEnum)(e);var i,s;n>=(0,r.logLevelStringToEnum)(o)&&(i=n,s="function"==typeof t?t():t,console.log(`[${a[i]},${(new Date).toISOString()}]${s}`))},t.LOG_DEBUG=(...e)=>{i&&(0,t.LOG)(...e)}},6952:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAX_CLIP=t.MIN_CLIP=t.GemmUtil=t.PoolConvUtil=t.ShapeUtil=t.BroadcastUtil=t.MatMulUtil=void 0;class n{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=n;class r{static calcShape(e,t,r=!1){const a=e.length,o=t.length;if(0===a)return t;if(0===o)return e;const i=Math.max(e.length,t.length),s=new Array(i);if(r){if(a<2||o<2)return;const r=n.calcMatMulShape([e[a-2],e[a-1]],[t[o-2],t[o-1]]);if(void 0===r)return;[s[i-2],s[i-1]]=r}for(let n=r?3:1;n<=i;n++){const r=a-n<0?1:e[a-n],u=o-n<0?1:t[o-n];if(r!==u&&r>1&&u>1)return;s[i-n]=Math.max(r,u)}return s}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(1!==e[n-a]&&e[n-a]!==t[r-a])return!1;return!0}}t.BroadcastUtil=r;class a{static size(e){return a.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let a=t;a<n;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=e[a]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,null!=t?t:e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}}t.ShapeUtil=a;class o{static adjustPoolAttributes(e,t,n,r,a,o){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*n.length;e++)if(e<o.length){if(o[e]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[e]>=n[e]||o[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,a,i,s){if(s){if(a.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)o.adjustPadAndReturnShape(e[u+(i?1:2)],t[u],n[u],r[u],a,u,u+e.length-2,s)}}static computePoolOutputShape(e,t,n,r,a,i,s){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const u=[t[0],t[1]];return o.computeShapeHelper(e,t,u,n,r,a,i,s),u}static computeConvOutputShape(e,t,n,r,a,i,s){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const u=[e[0],t[0]];return o.computeShapeHelper(!1,e,u,n,r,a,i,s),u}static computeShapeHelper(e,t,n,r,a,i,s,u){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(o.adjustPadAndReturnShape(t[e+2],r[e],a[e],i[e],s,e,e+t.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,a,o,i,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[o]+a[i]-u)/t+1);switch(s){case"VALID":return a[o]=0,a[i]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return a[o]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),a[i]=n-a[o],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=o,t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,a,o){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,s,u;t?(i=e[1],s=e[0]):(i=e[0],s=e[1]);let l=-1;if(a?(u=n[0],l=1):(u=n[1],l=0),n[l]!==s)throw new Error("dimension mismatch");if(i<=0||u<=0||s<=0)throw new Error("invalid shape specified");if(o&&!r.isValidBroadcast(o,[i,u]))throw new Error("gemm: invalid bias shape for broadcast");return[i,u,s]}},t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22},387:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},7771:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGpuDataManager=void 0;const r=n(4955),a=n(1163),o=e=>16*Math.ceil(e/16);let i=0;class s{constructor(e){this.backend=e,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(e,t){const n=t.buffer,a=t.byteOffset,i=t.byteLength,s=o(i),u=this.storageCache.get(e);if(!u)throw new Error("gpu data for uploading does not exist");if(u.originalSize!==i)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${i}`);const l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=l.getMappedRange();new Uint8Array(c).set(new Uint8Array(n,a,i)),l.unmap();const d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(l,0,u.gpuData.buffer,0,s),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(l)}memcpy(e,t){const n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");const r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");const a=o(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const n=o(e),s=this.backend.device.createBuffer({size:n,usage:t}),u={id:i++,type:a.GpuDataType.default,buffer:s};return this.storageCache.set(u.id,{gpuData:u,originalSize:e}),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${u.id}`)),u}get(e){var t;return null===(t=this.storageCache.get(e))||void 0===t?void 0:t.gpuData}release(e){const t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),this.downloadCache.get(e)&&this.downloadCache.delete(e),t.originalSize}async download(e){const t=this.downloadCache.get(e);if(t)return t.data;const n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");const r=this.backend.getCommandEncoder();this.backend.endComputePass();const a=o(n.originalSize),i=this.backend.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});r.copyBufferToBuffer(n.gpuData.buffer,0,i,0,a),this.backend.flush();const s=new Promise((e=>{i.mapAsync(GPUMapMode.READ).then((()=>{const t=i.getMappedRange().slice(0);i.destroy(),e(t)}))}));return this.downloadCache.set(e,{data:s}),s}refreshPendingBuffers(){for(const e of this.buffersForUploadingPending)e.destroy();for(const e of this.buffersPending)e.destroy()}}t.createGpuDataManager=(...e)=>new s(...e)},8510:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGPU_OP_RESOLVE_RULES=void 0;const i=o(n(504)),s=n(9770),u=n(4271),l=n(1522),c=o(n(5262)),d=n(6031),p=n(2625),f=o(n(9302));t.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[f.abs]],["Acos",[f.acos]],["Acosh",[f.acosh]],["Add",[i.add]],["Asin",[f.asin]],["Asinh",[f.asinh]],["Atan",[f.atan]],["Atanh",[f.atanh]],["AveragePool",[c.averagePool,c.parseAveragePoolAttributes]],["Ceil",[f.ceil]],["ClipV10",[f.clipV10]],["Clip",[f.clip]],["Conv",[s.conv,s.parseConvAttributes]],["Cos",[f.cos]],["Cosh",[f.cosh]],["Div",[i.div]],["Elu",[f.elu,f.parseAlphaAttributes]],["Erf",[f.erf]],["Exp",[f.exp]],["Floor",[f.floor]],["Gemm",[u.gemm,u.parseGemmAttributes]],["GlobalAveragePool",[c.globalAveragePool,c.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[c.globalMaxPool,c.parseGlobalMaxPoolAttributes]],["LeakyRelu",[f.leakyRelu,f.parseAlphaAttributes]],["MatMul",[l.matMul]],["MaxPool",[c.maxPool,c.parseMaxPoolAttributes]],["Mul",[i.mul]],["Neg",[f.neg]],["Pow",[i.pow]],["Reciprocal",[f.reciprocal]],["ReduceMin",[d.reduceMin,d.parseReduceAttributes]],["ReduceMean",[d.reduceMean,d.parseReduceAttributes]],["ReduceMax",[d.reduceMax,d.parseReduceAttributes]],["ReduceSum",[d.reduceSum,d.parseReduceAttributes]],["ReduceProd",[d.reduceProd,d.parseReduceAttributes]],["ReduceL1",[d.reduceL1,d.parseReduceAttributes]],["ReduceL2",[d.reduceL2,d.parseReduceAttributes]],["ReduceLogSum",[d.reduceLogSum,d.parseReduceAttributes]],["ReduceLogSumExp",[d.reduceLogSumExp,d.parseReduceAttributes]],["ReduceSumSquare",[d.reduceSumSquare,d.parseReduceAttributes]],["Relu",[f.relu]],["Sigmoid",[f.sigmoid]],["Sin",[f.sin]],["Sinh",[f.sinh]],["Sqrt",[f.sqrt]],["Sub",[i.sub]],["Tan",[f.tan]],["Tanh",[f.tanh]],["ThresholdedRelu",[f.thresholdedRelu,f.parseAlphaAttributes]],["Transpose",[p.transpose,p.parseTransposeAttributes]]])},1427:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.biasActivationSnippet=t.activationFnSnippet=t.typeSnippet=void 0,t.typeSnippet=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}},t.activationFnSnippet=(e,t=!1,n=!1,r=3)=>"",t.biasActivationSnippet=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `},9456:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfo=void 0;const r=n(4955),a=n(6952),o=n(1163),i=n(1427),s=n(4085),u=n(158);t.createConv2DMatMulProgramInfo=(e,t,n,l,c,d,p,f,h)=>{const g="NHWC"===n.format,m=g?e[0].dims[3]:e[0].dims[1],b=l[0],v=g?l[2]:l[3],y=g?l[1]:l[2],w=g?l[3]:l[1],$=((m%4==0||m%3==0)&&g||v%4==0&&!g)&&w%4==0,_=g?w:v*y,S=g?v*y:w,A=$?[8,8,1]:[_<=4?4:16,_>4&&S<=4?4:16,1],E=$?[4,4,1]:[_<=4?1:2,_>4&&S<=4?1:2,1],O=[Math.ceil(_/A[0]/E[0]),Math.ceil(S/A[1]/E[1]),Math.ceil(b/A[2]/E[1])];(0,r.LOG_DEBUG)("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${O}`));const P=$?g&&m%4!=0?3:4:E[0],C=A[1]*E[1],T=A[0]*E[0],I=Math.max(A[0]*P,A[1]),x=c%C==0,R=d%T==0,k=p%I==0,M=$?[P,4,4]:[1,1,1],D=[`@group(0) @binding(0) var<storage, read> x: array<${$&&4===P?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?"vec4<f32>":"f32"}>;`];let j=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${$?"vec4<f32>":"f32"}) {\n        result[flatIndex] = ${$?"vec4<f32>":"f32"}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?"vec4<f32>":"f32"}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);\n      }`;return f&&(D.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),j+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {\n          return bias[coords.${g?"w":"y"}${$?"/ 4":""}];\n        }`),Object.assign(Object.assign({},t),{outputs:[{dims:l,dataType:e[0].dataType,gpuDataType:o.GpuDataType.default}],dispatchGroup:()=>({x:O[0],y:O[1],z:O[2]}),getShaderSource:()=>`\n        ${s.utilFunctions}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${D.join("")}\n        @group(0) @binding(${D.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;\n        //@group(0) @binding(${D.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${l.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${a.ShapeUtil.computeStrides(l).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${n.kernelShape[0]}, ${n.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${n.pads[0]}, ${n.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${n.strides[0]}, ${n.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${n.dilations[0]}, ${n.dilations[1]});\n        const dimAOuter : i32 = ${c};\n        const dimBOuter : i32 = ${d};\n        const dimInner : i32 = ${p};\n        ${j}\n        ${((e,t,n,r,a=!1,o,s=!1,u=4,l=4,c=4)=>{const d=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",p=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",g=e?"row":"col",m=e?"col":"row",b=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${g} / outWidth;\n    let outCol = ${g} % outWidth;\n\n    let WRow = ${m} / (filterDims[1] * inChannels);\n    let WCol = ${m} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${m} % inChannels;\n    var resData = ${(0,i.typeSnippet)(u)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\n      ${d}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}\n    }\n    return resData;`,v=e?t&&r?`\n    let col = colIn * ${u};\n    ${b}`:`\n    let col = colIn * ${u};\n    if (row < dimAOuter && col < dimInner) {\n      ${b}\n    }\n    return ${(0,i.typeSnippet)(u)}(0.0);`:r&&n?`\n    let col = colIn * ${u};\n    ${b}`:`\n    let col = colIn * ${u};\n    if (row < dimInner && col < dimBOuter) {\n      ${b}\n    }\n    return ${(0,i.typeSnippet)(u)}(0.0);`,y=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(l)}`,w=(0,i.typeSnippet)(c),$=e?(0,i.typeSnippet)(u):(0,i.typeSnippet)(l),_=e?(0,i.typeSnippet)(l):(0,i.typeSnippet)(u);return`\n    ${(0,i.activationFnSnippet)(o,s,4===c,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$} {\n      ${e?v:y}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${_} {\n      ${e?y:v}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n      let col = colIn * ${c};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${p}\n      ${(0,i.biasActivationSnippet)(a,o)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`})(g,x,R,k,f,void 0,!1,M[0],M[1],M[2])}\n            ${$?(0,u.makeMatMulPackedVec4Source)(E,A,!g,I):(0,u.makeMatMulPackedSource)(E,A,!g,I,!1,void 0,h)}`})}},4085:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.utilFunctions=void 0,t.utilFunctions="\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n"},158:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeMatMulPackedSource=t.makeMatMulPackedVec4Source=void 0,t.makeMatMulPackedVec4Source=(e,t,n=!1,r=32,a=!1,o=32,i=!1)=>{const s=t[1]*e[1],u=t[0]*e[0],l=n?s:r,c=n?r:s,d=l/t[0],p=r/t[1];if((!n||4!==d||4!==e[1])&&(n||3!==d&&4!==d)||l%t[0]!=0||r%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${n} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${d} must be 3 or 4.\n  tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub : array<array<vec${d}<f32>, ${l/d}>, ${c}>;\nvar<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/e[0]}>, ${r}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${d};\nconst tileInner = ${r};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = ${i?"0":"localRow * rowPerThread"};\n  let tileCol = i32(localId.x);\n\n  let globalRow = ${i?"0":"i32(globalId.y) * rowPerThread"};\n  let globalCol = i32(globalId.x);\n  let batch = ${a?"0":"i32(globalId.z)"};\n  let globalRowStart = i32(workgroupId.y) * ${s};\n\n  let numTiles = ${a?`${Math.ceil(o/r)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};\n\n  var acc: array<vec4<f32>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${p};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${f=n,f?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol);\n        "}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===d?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${((e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,d)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`;var f};const n=e=>e?"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol);\n            ":"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol);\n            ";t.makeMatMulPackedSource=(e,t,r=!1,a=32,o=!1,i=32,s=!1)=>{const u=e[1]*t[1],l=e[0]*t[0],c=r?u:a,d=r?a:u;if(d%t[1]!=0||c%t[0]!=0||a%t[1]!=0)throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);const p=d/t[1],f=c/t[0],h=a/t[1],g=s?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${u};\n    let globalColStart = i32(workgroupId.x) * ${l};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${n(r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol);\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<f32, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${u};\n\nlet tileRowA = i32(localId.y) * ${p};\nlet tileColA = i32(localId.x) * ${f};\nlet tileRowB = i32(localId.y) * ${h};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${n(r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol);\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<f32, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(r)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<f32, ${c}>, ${d}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${o?"0":"i32(globalId.z)"};\n    let numTiles = ${o?`${Math.ceil(i/a)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${o?`i32(globalId.z) * ${i}`:"0"};\n\n    var acc : array<array<f32, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${g}\n  }\n`}},504:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sub=t.pow=t.mul=t.div=t.add=void 0;const r=n(6952),a=n(1163),o=n(2075),i=(e,t,n,i,s)=>{const u={name:t,inputTypes:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},u),{get:()=>((e,t,n,i,s,u=t.dataType)=>{var l,c;const d=!r.ShapeUtil.areEqual(t.dims,n.dims);let p=t.dims,f=r.ShapeUtil.size(t.dims),h=!1;if(d){const e=r.BroadcastUtil.calcShape(t.dims,n.dims,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");p=e,f=r.ShapeUtil.size(p);let a=1;for(let e=0;e<p.length;e++){const r=null!==(l=t.dims[t.dims.length-e])&&void 0!==l?l:1;if(r!==(null!==(c=n.dims[n.dims.length-e])&&void 0!==c?c:1))break;a*=r}a%4==0&&(h=!0)}else h=!0;return Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,a,i,s,u,l,c="f32",d="f32",p="f32")=>{const f=r.ShapeUtil.size(a),h=Math.ceil(f/4);let g,m;"string"==typeof u?g=m=(e,t)=>`${u}((${e}),(${t}))`:"function"==typeof u?g=m=u:(g=u.scalar,m=u.vector);let b="";const v=(0,o.createIndicesHelper)("output",a);if(s){const e=e=>{const t=r.ShapeUtil.computeStrides(e),n=[];for(let r=e.length-1;r>=0;r--){const o=0===a.length?"0u":1===a.length?"(*outputIndices)":`(*outputIndices)[${r+a.length-e.length}]`;n.push(`${t[r]}u * (${o} % ${e[r]}u)`)}return n.length>0?n.join("+"):"0u"};b=`\n  ${v.o2iImpl}\n\n  fn calcOffsetA(outputIndices: ptr<function, ${v.iType}>) -> u32 {\n    return ${e(t)};\n  }\n\n  fn calcOffsetB(outputIndices: ptr<function, ${v.iType}>) -> u32 {\n    return ${e(n)};\n  }\n  `}let y;if(i)y=s?`\n      ${v.indicesVariableDeclaration("outputIndices")}\n      ${v.o2iCall("global_idx * 4u","outputIndices")}\n      let offsetA = calcOffsetA(&outputIndices);\n      let offsetB = calcOffsetB(&outputIndices);\n      outputData[global_idx] = ${m("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${m("aData[global_idx]","bData[global_idx]")};`;else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const e=e=>{const t=`aData[indexA${e}][componentA${e}]`,n=`bData[indexB${e}][componentB${e}]`;return`\n      ${v.o2iCall(`global_idx * 4u + ${e}u`,"outputIndices")}\n      let offsetA${e} = calcOffsetA(&outputIndices);\n      let offsetB${e} = calcOffsetB(&outputIndices);\n      let indexA${e} = offsetA${e} / 4u;\n      let indexB${e} = offsetB${e} / 4u;\n      let componentA${e} = offsetA${e} % 4u;\n      let componentB${e} = offsetB${e} % 4u;\n      outputData[global_idx][${e}] = ${g(t,n)};`};y=`\n      ${v.indicesVariableDeclaration("outputIndices")}\n      ${e(0)}\n      ${e(1)}\n      ${e(2)}\n      ${e(3)}`}return`\n  @group(0) @binding(0) var<storage, read> aData : array<vec4<${c}>>;\n  @group(0) @binding(1) var<storage, read> bData : array<vec4<${d}>>;\n  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${p}>>;\n\n  ${null!=l?l:""}\n  ${b}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n    ${y}\n  }`})(e,t.dims,n.dims,p,h,d,i,s),outputs:[{dims:p,dataType:u,gpuDataType:a.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(f/64/(h?4:1))})})})(u,e[0],e[1],n,i)})};t.add=e=>{e.compute(i(e.inputs,"Add",((e,t)=>`${e}+${t}`)))},t.div=e=>{e.compute(i(e.inputs,"Div",((e,t)=>`${e}/${t}`)))},t.mul=e=>{e.compute(i(e.inputs,"Mul",((e,t)=>`${e}*${t}`)))},t.pow=e=>{e.compute(i(e.inputs,"Pow",{scalar:(e,t)=>`pow_f32(${e},${t})`,vector:(e,t)=>`pow_vf32(${e},${t})`},"\n    fn pow_f32(a : f32, b : f32) -> f32 {\n      if (b == 0.0) {\n        return 1.0;\n      } else if (a < 0.0 && b != floor(b)) {\n        return pow(a, b); // NaN\n      }\n      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);\n    }\n    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n      // TODO: implement vectorized pow\n      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));\n    }\n      "))},t.sub=e=>{e.compute(i(e.inputs,"Sub",((e,t)=>`${e}-${t}`)))}},2075:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createShaderHelper=t.createIndicesHelper=t.WORKGROUP_SIZE=void 0;const r=n(6952);t.WORKGROUP_SIZE=64,t.createIndicesHelper=(e,t)=>{const n=t.length<2?"u32":`array<u32, ${t.length}>`,a=r.ShapeUtil.computeStrides(t);let o="";for(let e=0;e<t.length-1;e++)o+=`\n    let dim${e} = current / ${a[e]}u;\n    let rest${e} = current % ${a[e]}u;\n    (*indices)[${e}] = dim${e};\n    current = rest${e};\n    `;o+=`(*indices)[${t.length-1}] = current;`;const i=t.length<2?"":`\n  fn ih_o2i_${e}(offset: u32, indices: ptr<function, ${n}>) {\n    var current = offset;\n    ${o}\n  }`,s=[];if(0===t.length)s.push("0u");else if(t.length<2)s.push("(*indices)");else for(let e=t.length-1;e>=0;e--)s.push(`${a[e]}u * ((*indices)[${e}])`);return{o2iImpl:i,o2iCall:(n,r)=>t.length<2?`${r}=${n};`:`ih_o2i_${e}(${n}, &${r});`,i2oImpl:t.length<2?"":`\n  fn ih_i2o_${e}(indices: ptr<function, ${n}>) -> u32 {\n    return ${s.join("+")};\n  }`,i2oExpression:(n,r)=>t.length<2?`(${r?"*":""}${n})`:`ih_i2o_${e}(${r?"":"&"}${n})`,indicesVariableDeclaration:(e,t)=>`var ${e}:${n}${t?`=${n}(${t.join(",")})`:""};`,iType:n}};class a{constructor(e){this.normalizedDispatchGroup=e}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=t.WORKGROUP_SIZE){const n="number"==typeof e?e:e[0],r="number"==typeof e?1:e[1],a="number"==typeof e?1:e[2],o=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${n}, ${r}, ${a})\n  fn main(${o?"@builtin(global_invocation_id) global_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\n    ${o?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${n*r*a}u + local_index;`}\n  `}}t.createShaderHelper=e=>new a(e)},9192:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGroupedConvProgramInfoLoader=void 0;const r=n(6952),a=n(1163),o=n(2075),i=n(9770),s=n(3997);t.createGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=e.length>2,c=t.cacheKey,{name:"GroupedConv",inputTypes:l?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=e.length>2,c=l?"value += b[output_channel];":"",d=e[0].dims,p=e[1].dims,f=p[0]/n.group,h="f32",{activationFunction:g,applyActivation:m}=(0,s.getActicationSnippet)(n),b=[`@group(0) @binding(0) var<storage, read> x : array<${h}>;`,`@group(0) @binding(1) var<storage, read> w : array<${h}>;`];l&&b.push(`@group(0) @binding(2) var<storage, read> b : array<${h}>;`);const v="NHWC"===n.format,y=(0,i.calculateOutputShape)(d,p,n.dilations,n.pads,n.strides,v),w=r.ShapeUtil.size(y),$=(0,o.createIndicesHelper)("output",y),_=(0,o.createIndicesHelper)("x",d),S=(0,o.createIndicesHelper)("w",p);return Object.assign(Object.assign({},t),{outputs:[{dims:u?u(y):y,dataType:e[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\n  const strides: vec2<u32> = vec2(${n.strides[0]}u, ${n.strides[1]}u);\n  const pads: vec2<u32> = vec2(${n.pads[0]}u, ${n.pads[1]}u);\n\n  ${b.join("\n")}\n  @group(0) @binding(${b.length}) var<storage, read_write> output : array<${h}>;\n\n  ${g}\n  ${$.o2iImpl}\n  ${_.i2oImpl}\n  ${S.i2oImpl}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n\n    ${$.indicesVariableDeclaration("outputIndices")}\n    ${$.o2iCall("global_idx","outputIndices")}\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${v?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${v?1:2}], outputIndices[${v?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${f}u;\n\n    var value: ${h} = ${h}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${p[1]}u; wInChannel++) {\n      let input_channel = group_id * ${p[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${p[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${n.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${d[v?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${p[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${n.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${d[v?2:3]}u) {\n            continue;\n          }\n\n          ${_.indicesVariableDeclaration("xIndices",v?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}\n          let xVal = x[${_.i2oExpression("xIndices")}];\n          ${S.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}\n          let wVal = w[${S.i2oExpression("wIndices")}];\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${c}\n    ${m}\n    output[global_idx] = value;\n  }`,dispatchGroup:()=>({x:Math.ceil(w/64)})})})(e,u,t,n)})}},9770:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv=t.parseConvAttributes=t.calculateOutputShape=void 0;const r=n(6952),a=n(387),o=n(9192),i=n(3822),s=n(3997),u=n(2625);t.calculateOutputShape=(e,t,n,r,a,o)=>{const i=e[0],s=e.slice(o?1:2,o?3:4),u=s.length,l=t[0],c=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),d=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-c[t]+a[t])/a[t])));return d.splice(0,0,i),d.splice(o?3:1,0,l),d};const l=(0,a.createAttributeWithCacheKey)({perm:[2,3,1,0]}),c=(e,t)=>{const n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);const a=e.pads.slice();r.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,a,"NHWC"===e.format,e.autoPad);const o=Object.assign({},e);return Object.assign(o,{kernelShape:n,pads:a,cacheKey:e.cacheKey}),o};t.parseConvAttributes=e=>{const t=(0,s.parseInternalActivationAttributes)(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],o=e.dilations,i=e.group,u=e.kernel_shape,l=e.pads,c=e.strides,d=e.w_is_const();return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:n,dilations:o,group:i,kernelShape:u,pads:l,strides:c,wIsConst:d},t))},t.conv=(e,n)=>{((e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&1!==e[2].dataType)throw new Error("Conv input(bias) should be float tensor")})(e.inputs,n),3===e.inputs[0].dims.length?((e,t)=>{const n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);const a=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),s=[1].concat(t.dilations),u=[1].concat(t.kernelShape),l=c(Object.assign(Object.assign({},t),{pads:a,strides:i,dilations:s,kernelShape:u}),r);e.compute((0,o.createGroupedConvProgramInfoLoader)(r,l,(e=>n?[e[0],e[2],e[3]]:[])))})(e,n):((e,n,r)=>{var a;const s=c(r,n),d=3===n.length,p="NHWC"===r.format,f=n[0].dims[p?1:2],h=n[0].dims[p?2:3],g=n[0].dims[p?3:1],m=n[1].dims[2],b=n[1].dims[3],v=(0,t.calculateOutputShape)(n[0].dims,n[1].dims,r.dilations,s.pads,r.strides,p),y=v[p?1:2],w=v[p?2:3],$=v[p?3:1];if(p&&m===f&&b===h&&"VALID"===r.autoPad||1===m&&1===b&&1===r.dilations[0]&&1===r.dilations[1]&&1===r.strides[0]&&1===r.strides[1]&&("SAME_UPPER"===r.autoPad||"SAME_LOWER"===r.autoPad||"VALID"===r.autoPad))return void e.compute((0,o.createGroupedConvProgramInfoLoader)(n,s));if(!p||1!==r.group)return void e.compute((0,o.createGroupedConvProgramInfoLoader)(n,s));const _=p?y*w:$,S=p?$:y*w,A=m*b*g,E=null!==(a=e.customData.wT)&&void 0!==a?a:e.compute(Object.assign(Object.assign({},u.transposeProgramMetadata),{cacheHint:l.cacheKey,get:()=>(0,u.createTransposeProgramInfo)(n[1],l.perm)}),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.customData.wT&&(e.customData.wT=E);const O=[n[0],E];d&&(p||1!==n[2].dims.length?O.push(n[2]):O.push(n[2].reshape([n[2].dims[0],1,1]))),e.compute((0,i.createConv2DMatMulProgramInfoLoader)(O,s,v,_,S,A,d,!0),{inputs:O})})(e,e.inputs,n)}},3822:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfoLoader=void 0;const r=n(1163),a=n(9456);t.createConv2DMatMulProgramInfoLoader=(e,t,n,o,i,s,u,l)=>{const c=((e,t)=>({name:"Conv2DMatMul",inputTypes:e?[r.GpuDataType.default,r.GpuDataType.default,r.GpuDataType.default]:[r.GpuDataType.default,r.GpuDataType.default],cacheHint:t}))(u,t.cacheKey);return Object.assign(Object.assign({},c),{get:()=>(0,a.createConv2DMatMulProgramInfo)(e,c,t,n,o,i,s,u,l)})}},3997:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActicationSnippet=void 0;const r=n(6952);t.getActicationSnippet=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},t.parseInternalActivationAttributes=e=>{const t=(null==e?void 0:e.activation)||"";if("Clip"===t){const[n,a]=(null==e?void 0:e.activation_params)||[r.MIN_CLIP,r.MAX_CLIP];return{activation:t,clipMax:a,clipMin:n,activationCacheKey:`${t}:${n},${a}`}}return{activation:t,activationCacheKey:t}}},4271:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributes=t.gemm=void 0;const r=n(6952),a=n(387),o=n(1163);t.gemm=(e,t)=>{(e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(1!==e[0].dataType||1!==e[1].dataType||3===e.length&&1!==e[2].dataType)throw new Error("Invalid input type.");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")})(e.inputs),e.compute(((e,t)=>{const n={name:"Gemm",inputTypes:3===e.length?[o.GpuDataType.default,o.GpuDataType.default,o.GpuDataType.default]:[o.GpuDataType.default,o.GpuDataType.default],cacheHint:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const a=t[0].dims.slice(),i=t[1].dims.slice(),[s,u,l]=r.GemmUtil.getShapeOfGemmResult(a,n.transA,i,n.transB,3===t.length?t[2].dims:void 0),c=[s,u];if(!c)throw new Error("Can't use gemm on the given tensors");const d=r.ShapeUtil.size(c);let p="";n.transA&&n.transB?p="value += a[k * M + m] * b[n * K + k];":n.transA&&!n.transB?p="value += a[k * M + m] * b[k * N + n];":!n.transA&&n.transB?p="value += a[m * K + k] * b[n * K + k];":n.transA||n.transB||(p="value += a[m * K + k] * b[k * N + n];");const f="f32",h=1===n.alpha?"":"value *= alpha;",g=3===t.length?`value += beta * c[${((e,t,n)=>{if(0===n.length)return"0u";const r=1===n.length&&1!==e||2===n.length&&n[0]!==e,a=n[n.length-1]!==t;let o="0u";return r||(o+=`+ m * ${n[n.length-1]}u`),a||(o+="+n"),o})(s,u,t[2].dims)}];`:"",m=[`@group(0) @binding(0) var<storage, read> a : array<${f}>;`,`@group(0) @binding(1) var<storage, read> b : array<${f}>;`];return 3===t.length&&m.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`),Object.assign(Object.assign({},e),{outputs:[{dims:c,dataType:t[0].dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:e=>`\n  const M: u32 = ${s}u;\n  const N: u32 = ${u}u;\n  const K: u32 = ${l}u;\n  const alpha = ${f}(${n.alpha});\n  const beta = ${f}(${n.beta});\n\n  ${m.join("\n")}\n  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${f}>;\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${f}(0);\n    for (var k: u32 = 0u; k<${l}u; k++) {\n      ${p}\n    }\n\n    ${h}\n    ${g}\n    output[global_id.x] = value;\n\n  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(n,e,t)})})(e.inputs,t))},t.parseGemmAttributes=e=>(0,a.createAttributeWithCacheKey)(e)},1522:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.matMul=t.createMatmulProgramInfoLoader=void 0;const r=n(6952),a=n(1163),o=n(3997);t.createMatmulProgramInfoLoader=(e,t)=>{const n=(i=e.length>2,s=t.activationCacheKey,{name:"MatMul",inputTypes:i?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s});var i,s;return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const i=t[0].dims,s=t[1].dims,u=r.BroadcastUtil.calcShape(i,s,!0);if(!u)throw new Error("Can't use matmul on the given tensors");const l=r.ShapeUtil.size(u),c="f32",{activationFunction:d,applyActivation:p}=(0,o.getActicationSnippet)(n),f=u[u.length-2],h=i[i.length-1],g=u[u.length-1];return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\n  const M: u32 = ${f}u;\n  const N: u32 = ${g}u;\n  const K: u32 = ${h}u;\n\n  @group(0) @binding(0) var<storage, read> a : array<${c}>;\n  @group(0) @binding(1) var<storage, read> b : array<${c}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${c}>;\n\n  ${d}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n    let stack = global_idx / (M * N);\n    let mn = global_idx % (M * N);\n    let n = global_idx % N;\n    let m = mn / N;\n\n    let offsetA = stack * (M * K);\n    let offsetB = stack * (K * N);\n\n    var value = ${c}(0);\n    for (var k: u32 = 0u; k<${h}u; k++) {\n      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];\n    }\n    ${p}\n    output[global_idx] = value;\n  }`,dispatchGroup:()=>({x:Math.ceil(l/64)})})})(n,e,t)})},t.matMul=e=>{(e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs),e.compute((0,t.createMatmulProgramInfoLoader)(e.inputs,{activation:"",activationCacheKey:""}))}},5262:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseGlobalMaxPoolAttributes=t.parseMaxPoolAttributes=t.maxPool=t.globalAveragePool=t.parseGlobalAveragePoolAttributes=t.averagePool=t.parseAveragePoolAttributes=void 0;const r=n(6952),a=n(387),o=n(1163),i=n(2075),s=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length)throw new Error("Pool ops supports 2-D inputs only for now.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=(e,t,n)=>{const a="NHWC"===t.format,o=a?[e[0].dims[0],e[0].dims[3],e[0].dims[1],e[0].dims[2]]:e[0].dims.slice(),i=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),u=t.strides.slice(),l=i?t.dilations.slice():[],c=t.pads.slice();r.PoolConvUtil.adjustPoolAttributes(n,o,s,u,l,c);const d=r.PoolConvUtil.computePoolOutputShape(n,o,u,l,s,c,t.autoPad),p=Object.assign({},t);return i?Object.assign(p,{kernelShape:s,strides:u,pads:c,dilations:l,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:s,strides:u,pads:c,cacheKey:t.cacheKey}),[p,a?[d[0],d[2],d[3],d[1]]:d]},l=(e,t,n,a,o,s,u,l)=>{const c="NHWC"===a.format,d=t.length,p=r.ShapeUtil.size(n),f=(0,i.createIndicesHelper)("output",n),h=(0,i.createIndicesHelper)("x",t);if(a.kernelShape.length<=2){const n=a.kernelShape[a.kernelShape.length-1],r=a.strides[a.strides.length-1],i=a.pads[a.pads.length/2-1],g=d-(c?2:1);let m="",b="",v="";if(m=i+a.pads[a.pads.length-1]!==0?`\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                xIndices[${g}] = indices[${g}] * ${r} - ${i} + i;\n                if (xIndices[${g}] < 0 || xIndices[${g}] >= ${t[g]}) {\n                  pad++;\n                  continue;\n                }\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${o}\n              }`:`\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                xIndices[${g}] = indices[${g}] * ${r} - ${i} + i;\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${o}\n              }`,2===a.kernelShape.length){const e=a.kernelShape[a.kernelShape.length-2],r=a.strides[a.strides.length-2],o=a.pads[a.pads.length/2-2],i=a.pads[a.pads.length-2],s=d-(c?3:2),u=t[s];b=o+i!==0?`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${s}] = indices[${s}] * ${r} - ${o} + j;\n                  if (xIndices[${s}] < 0 || xIndices[${s}] >= ${u}) {\n                    pad+= ${n};\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${s}] = indices[${s}] * ${r} - ${o} + j;\n                `,v="\n              }\n            "}return`\n            @group(0) @binding(0) var<storage, read> x : array<${u}>;\n            @group(0) @binding(1) var<storage, read_write> output : array<${u}>;\n\n            ${f.o2iImpl}\n            ${h.i2oImpl}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              ${f.indicesVariableDeclaration("indices")}\n              ${f.o2iCall("global_idx","indices")}\n              ${f.indicesVariableDeclaration("xIndices")}\n              ${f.o2iCall("global_idx","xIndices")}\n\n              var value: ${u} = ${u}(${l});\n              var pad = 0;\n              ${b}\n              ${m}\n              ${v}\n              ${s}\n\n              output[global_idx] = value;\n            }`}{if(c)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const n=r.ShapeUtil.size(a.kernelShape),i=r.ShapeUtil.computeStrides(a.kernelShape),g=i.length,m=a.pads.length;let b="";return b=a.pads.reduce(((e,t)=>e+t))?`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${o}\n              }`:`\n              }\n              let x_val = x[${h.i2oExpression("xIndices")}];\n              ${o}\n            `,`\n            @group(0) @binding(0) var<storage, read> x : array<${u}>;\n            @group(0) @binding(1) var<storage, read_write> output : array<${u}>;\n\n            ${f.o2iImpl}\n            ${h.i2oImpl}\n\n            const pads = array<u32, ${m}>(${a.pads.map((e=>`${e}u`)).join(",")});\n            const inputDims = array<u32, ${d}>(${t.map((e=>`${e}u`)).join(",")});\n            const kernelStrides = array<u32, ${g}>(${i.map((e=>`${e}u`)).join(",")});\n            const strides = array<u32, ${g}>(${a.strides.map((e=>`${e}u`)).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              ${f.indicesVariableDeclaration("indices")}\n              ${f.o2iCall("global_idx","indices")}\n              ${f.indicesVariableDeclaration("xIndices")}\n              ${f.o2iCall("global_idx","xIndices")}\n\n              var offsets: array<u32, ${g}>;\n\n              var value = ${u}(${l});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${g-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${g-1}] = offset;\n\n                isPad = false;\n                for (var j = ${d-g}u; j < ${d}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${d-g}u]\n                    + offsets[j - ${d-g}u] - pads[j - 2u];\n                  ${b}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},c=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),d=(e,t,n,a)=>{const[i,s]=u(e,a,n),c=r.ShapeUtil.size(i.kernelShape),d="f32";let p="";return i.countIncludePad?p+=`value /= ${d}(${c});`:p+=`value /= ${d}(${c} - pad);`,Object.assign(Object.assign({},t),{outputs:[{dims:s,dataType:e[0].dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:t=>l(t,e[0].dims,s,i,"value += x_val;",p,d,"0.0"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(s)/64)})})};t.parseAveragePoolAttributes=e=>{const t=0!==e.count_include_pad,n=c(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,a.createAttributeWithCacheKey)(Object.assign({countIncludePad:t},n))},t.averagePool=(e,t)=>{s(e.inputs);const n={name:"AveragePool",inputTypes:[o.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>d(e.inputs,n,!1,t)}))};const p={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};t.parseGlobalAveragePoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},p),{cacheKey:t})},t.globalAveragePool=(e,t)=>{s(e.inputs);const n={name:"GlobalAveragePool",inputTypes:[o.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>d(e.inputs,n,!0,t)}))};const f=(e,t,n,a)=>{const[i,s]=u(e,a,n);return Object.assign(Object.assign({},t),{outputs:[{dims:s,dataType:e[0].dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:t=>l(t,e[0].dims,s,i,"\n      value = max(x_val, value);\n    ","","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(s)/64)})})};t.maxPool=(e,t)=>{s(e.inputs);const n={name:"MaxPool",inputTypes:[o.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs,n,!1,t)}))},t.parseMaxPoolAttributes=e=>{const t=e.storage_order,n=e.dilations,r=c(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,a.createAttributeWithCacheKey)(Object.assign({storageOrder:t,dilations:n},r))},t.parseGlobalMaxPoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},p),{cacheKey:t})},t.globalMaxPool=(e,t)=>{s(e.inputs);const n={name:"GlobalMaxPool",inputTypes:[o.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs,n,!0,t)}))}},6031:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseReduceAttributes=t.reduceSumSquare=t.reduceSum=t.reduceProd=t.reduceMin=t.reduceMean=t.reduceMax=t.reduceLogSumExp=t.reduceL2=t.reduceL1=t.reduceLogSum=void 0;const r=n(6952),a=n(387),o=n(1163),i=n(2075),s=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=()=>["","","value = _A[inputIdx];",""],l=(e,t,n,s)=>{const l=1===e.length?n:((e,t)=>{const n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),(0,a.createAttributeWithCacheKey)({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})})(e,n),c={name:t,inputTypes:[o.GpuDataType.default],cacheHint:l.cacheKey};return Object.assign(Object.assign({},c),{get:()=>((e,t,n,a)=>{const s=[],u=t[0].dims,l=[],c=r.ShapeUtil.normalizeAxes(n.axes,t[0].dims.length),d=t[0].dims.length-(n.keepDims?0:c.length),p=a(t,c),f=(0,i.createIndicesHelper)("input",u),h=""===p[1]?"":`let inputIdx = ${f.i2oExpression("inputIndices")};`;let g=`\n          let inputIdx = ${f.i2oExpression("inputIndices")};\n          ${p[2]};`;const m=!n.noopWithEmptyAxes&&0===n.axes.length;for(let e=0;e<t[0].dims.length;e++)m||c.indexOf(e)>=0?(n.keepDims&&s.push(1),g=`for(var j${e}: u32 = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\n                            inputIndices[${e}] = j${e};\n                            ${g}\n                          }`):(d>1?l.push(`inputIndices[${e}] = outputIndices[${s.length}];`):l.push(`inputIndices[${e}] = outputIndices;`),s.push(t[0].dims[e]));const b=(0,i.createIndicesHelper)("output",s),v=r.ShapeUtil.size(s),y="f32";return Object.assign(Object.assign({},e),{getShaderSource:e=>`\n          @group(0) @binding(0) var<storage, read> _A : array<${y}>;\n          @group(0) @binding(1) var<storage, read_write> output : array<${y}>;\n\n          ${b.o2iImpl}\n          ${f.i2oImpl}\n\n          ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(v)}\n          ${f.indicesVariableDeclaration("inputIndices")}\n          ${b.indicesVariableDeclaration("outputIndices")}\n          ${b.o2iCall("global_idx","outputIndices")}\n\n          var value = ${y}(0);\n\n          ${l.join("\n")}\n          ${p[0]}       // init ops for reduce max/min\n          ${h}\n          ${p[1]}\n          ${g}\n          ${p[3]}       // final computation for reduce mean\n          output[global_idx] = value;\n        }`,outputs:[{dims:s,dataType:t[0].dataType,gpuDataType:o.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(v/64)})})})(c,[e[0]],l,l.noopWithEmptyAxes&&0===l.axes.length?u:s)})};t.reduceLogSum=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceLogSum",t,(()=>["value = 0.0;","","value += _A[inputIdx];","value = log(value);"])),{inputs:[0]})},t.reduceL1=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceL1",t,(()=>["value = 0.0;","","value += abs(_A[inputIdx]);",""])),{inputs:[0]})},t.reduceL2=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceL2",t,(()=>["var t = f32(0); value = 0.0;","","t = _A[inputIdx]; value += (t * t);","value = sqrt(value);"])),{inputs:[0]})},t.reduceLogSumExp=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceLogSumExp",t,(()=>["value = 0.0;","","value += exp(_A[inputIdx]);","value = log(value);"])),{inputs:[0]})},t.reduceMax=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMax",t,((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIndices[${r}] = 0;`);return[`${n.join("\n")}`,"value = _A[inputIdx];","value = max(value, _A[inputIdx]);",""]})),{inputs:[0]})},t.reduceMean=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMean",t,((e,t)=>{let n=1;for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&(n*=e[0].dims[r]);return["value = 0.0;","","value += _A[inputIdx];",`value = value / ${n}.;`]})),{inputs:[0]})},t.reduceMin=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMin",t,((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIndices[${r}] = 0;`);return[`${n.join("\n")}`,"value = _A[inputIdx];","value = min(value, _A[inputIdx]);",""]})),{inputs:[0]})},t.reduceProd=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceProd",t,(()=>["value = 1.0;","","value *= _A[inputIdx];",""])),{inputs:[0]})},t.reduceSum=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceSum",t,(()=>["value = 0.0;","","value += _A[inputIdx];",""])),{inputs:[0]})},t.reduceSumSquare=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceSumSquare",t,(()=>["var t = f32(0); value = 0.0;","","t = _A[inputIdx]; value += t * t;",""])),{inputs:[0]})},t.parseReduceAttributes=e=>(0,a.createAttributeWithCacheKey)(e)},2625:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=t.createTransposeProgramInfo=t.transposeProgramMetadata=void 0;const r=n(6952),a=n(387),o=n(1163),i=n(2075);t.transposeProgramMetadata={name:"Transpose",inputTypes:[o.GpuDataType.default]};const s=(e,t)=>t&&t.length!==e.length?[...e.keys()].reverse():t;t.createTransposeProgramInfo=(e,n)=>{const a=e.dims,u=s(a,n),l=((e,t)=>r.ShapeUtil.sortBasedOnPerm(e,s(e,t)))(a,u),c=a.length,d=r.ShapeUtil.size(l),p=(0,i.createIndicesHelper)("output",l),f=(0,i.createIndicesHelper)("a",a);return Object.assign(Object.assign({},t.transposeProgramMetadata),{outputs:[{dims:l,dataType:e.dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:e=>`\n  @group(0) @binding(0) var<storage, read> a : array<f32>;\n  @group(0) @binding(1) var<storage, read_write> output : array<f32>;\n\n  ${((e,t)=>{const n=[];n.push(`fn perm(a: ptr<function, array<u32, ${t}>>, i: ptr<function, array<u32, ${t}>>) {`);for(let r=0;r<t;++r)n.push(`\t(*a)[${e[r]}]=(*i)[${r}];`);return n.push("\t}"),n.join("\n")})(u,c)}\n  ${p.o2iImpl}\n  ${f.i2oImpl}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n    ${p.indicesVariableDeclaration("indices")}\n    ${p.o2iCall("global_idx","indices")}\n    ${f.indicesVariableDeclaration("aIndices")}\n    perm(&aIndices, &indices);\n\n    output[global_idx] = a[${f.i2oExpression("aIndices")}];\n  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})},t.transpose=(e,n)=>{(e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(1!==e[0].dataType)throw new Error("input should be float tensor")})(e.inputs),e.compute(Object.assign(Object.assign({},t.transposeProgramMetadata),{cacheHint:n.cacheKey,get:()=>(0,t.createTransposeProgramInfo)(e.inputs[0],n.perm)}))},t.parseTransposeAttributes=e=>(0,a.createAttributeWithCacheKey)({perm:e.perm})},9302:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.thresholdedRelu=t.tanh=t.tan=t.sqrt=t.sinh=t.sin=t.sigmoid=t.relu=t.reciprocal=t.neg=t.leakyRelu=t.floor=t.exp=t.erf=t.elu=t.parseAlphaAttributes=t.cosh=t.cos=t.ceil=t.clip=t.clipV10=t.atanh=t.atan=t.asinh=t.asin=t.acosh=t.acos=t.abs=void 0;const r=n(6952),a=n(387),o=n(1163),i=(e,t,n,a,i)=>{const s={name:t,inputTypes:[o.GpuDataType.default],cacheHint:i};return Object.assign(Object.assign({},s),{get:()=>((e,t,n,a)=>Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,r)=>{const a=Math.ceil(t/4);let o="";return o="string"==typeof n?`${n}(a)`:n("a"),`\n  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;\n  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;\n\n  ${null!=r?r:""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    let a = inputData[global_idx];\n    outputData[global_idx] = ${o};\n  }`})(e,r.ShapeUtil.size(t.dims),n,a),outputs:[{dims:t.dims,dataType:t.dataType,gpuDataType:o.GpuDataType.default}],dispatchGroup:e=>({x:Math.ceil(r.ShapeUtil.size(e[0].dims)/64/4)})}))(s,e,n,a)})};t.abs=e=>{e.compute(i(e.inputs[0],"Abs","abs"))},t.acos=e=>{e.compute(i(e.inputs[0],"Acos","acos"))},t.acosh=e=>{e.compute(i(e.inputs[0],"Acosh","acosh"))},t.asin=e=>{e.compute(i(e.inputs[0],"Asin","asin"))},t.asinh=e=>{e.compute(i(e.inputs[0],"Asinh","asinh"))},t.atan=e=>{e.compute(i(e.inputs[0],"Atan","atan"))},t.atanh=e=>{e.compute(i(e.inputs[0],"Atanh","atanh"))},t.clipV10=(e,t)=>{e.compute(i(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<f32> = vec4(f32(${t.min}));\n    const clip_max_: vec4<f32> = vec4(f32(${t.max}));\n`,t.cacheKey),{inputs:[0]})},t.clip=e=>{const n=(e=>{const t=e.length>=2?e[1].getFloat32Array()[0]:r.MIN_CLIP,n=e.length>=3?e[2].getFloat32Array()[0]:r.MAX_CLIP;return(0,a.createAttributeWithCacheKey)({min:t,max:n})})(e.inputs);(0,t.clipV10)(e,n)},t.ceil=e=>{e.compute(i(e.inputs[0],"Ceil","ceil"))},t.cos=e=>{e.compute(i(e.inputs[0],"Cos","cos"))},t.cosh=e=>{e.compute(i(e.inputs[0],"Cosh","cosh"))},t.parseAlphaAttributes=e=>(0,a.createAttributeWithCacheKey)(e),t.elu=(e,t)=>{e.compute(i(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},t.erf=e=>{e.compute(i(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),"\n  const r0: f32 = 0.3275911;\n  const r1: f32 = 0.254829592;\n  const r2: f32 = -0.284496736;\n  const r3: f32 = 1.421413741;\n  const r4: f32 = -1.453152027;\n  const r5: f32 = 1.061405429;\n\n  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {\n    let absv = abs(v);\n    let x = 1.0 / (1.0 + r0 * absv);\n    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n  }"))},t.exp=e=>{e.compute(i(e.inputs[0],"Exp","exp"))},t.floor=e=>{e.compute(i(e.inputs[0],"Floor","floor"))},t.leakyRelu=(e,t)=>{e.compute(i(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},t.neg=e=>{e.compute(i(e.inputs[0],"Neg",(e=>`-${e}`)))},t.reciprocal=e=>{e.compute(i(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},t.relu=e=>{e.compute(i(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},t.sigmoid=e=>{e.compute(i(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},t.sin=e=>{e.compute(i(e.inputs[0],"Sin","sin"))},t.sinh=e=>{e.compute(i(e.inputs[0],"Sinh","sinh"))},t.sqrt=e=>{e.compute(i(e.inputs[0],"Sqrt","sqrt"))},t.tan=e=>{e.compute(i(e.inputs[0],"Tan","tan"))},t.tanh=e=>{e.compute(i(e.inputs[0],"Tanh","tanh"))},t.thresholdedRelu=(e,t)=>(e.compute(i(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0)},8305:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(4955),a=n(2075);t.ProgramManager=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r){const a=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&o.writeTimestamp(this.backend.profilingQuerySet,0),o.setPipeline(e.computePipeline);const i=[];for(const e of t)i.push({binding:i.length,resource:{buffer:e.buffer}});for(const e of n)i.push({binding:i.length,resource:{buffer:e.buffer}});const s=a.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:i});if(o.setBindGroup(0,s),o.dispatchWorkgroups(...r),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){o.writeTimestamp(this.backend.profilingQuerySet,1);const e=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),t=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,e.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(e.buffer,0,t.buffer,0,16),this.backend.flush();const n=this.backend.currentKernelId,r=this.backend.kernels.get(n)[0];t.buffer.mapAsync(GPUMapMode.READ).then((()=>{const a=new BigUint64Array(t.buffer.getMappedRange()),o=a[0],i=a[1];t.buffer.unmap(),void 0===this.backend.profilingTimeBase&&(this.backend.profilingTimeBase=o);const s=Number(o-this.backend.profilingTimeBase),u=Number(i-this.backend.profilingTimeBase);if(!Number.isSafeInteger(s)||!Number.isSafeInteger(u))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id),this.backend.gpuDataManager.release(t.id),console.log(`[profiling] kernel "${n}|${r}" execution time: ${u-s} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){const n=this.backend.device,o=e.getShaderSource((0,a.createShaderHelper)(t)),i=n.createShaderModule({code:o});return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] shader code: ${o}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:i,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(e){const t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&n<=a&&r<=a)return[t,n,r];const o=t*n*r;let i=Math.ceil(Math.sqrt(o));if(i>a){if(i=Math.ceil(Math.cbrt(o)),i>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[i,i,i]}return[i,i,1]}}},1163:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.GpuDataType=void 0,(n=t.GpuDataType||(t.GpuDataType={}))[n.default=0]="default",n[n.upload=1]="upload",n[n.profile=2]="profile"},9544:function(e,t,n){"use strict";var r,a=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&a(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initializeRuntime=t.initializeWebAssemblyInstance=void 0;const s=n(2235),u=i(n(1259)),l=n(263);"undefined"!=typeof document&&(null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r||r.src),t.initializeWebAssemblyInstance=async()=>(0,l.initializeWebAssembly)(s.env.wasm),t.initializeRuntime=async e=>{await u.initRuntime(e)},t.createSessionAllocate=async e=>u.createSessionAllocate(e),t.createSessionFinalize=async(e,t)=>u.createSessionFinalize(e,t),t.createSession=async(e,t)=>u.createSession(e,t),t.releaseSession=async e=>{u.releaseSession(e)},t.run=async(e,t,n,r,a)=>u.run(e,t,n,r,a),t.endProfiling=async e=>{u.endProfiling(e)}},7918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(263),a=n(1497);t.setRunOptions=e=>{const t=(0,r.getInstance)();let n=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let r=0;return void 0!==(null==e?void 0:e.tag)&&(r=(0,a.allocWasmString)(e.tag,o)),n=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,r),0===n&&(0,a.checkLastError)("Can't create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(r,o);0!==t._OrtAddRunConfigEntry(n,i,s)&&(0,a.checkLastError)(`Can't set a run config entry: ${e} - ${r}.`)})),[n,o]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),o.forEach((e=>t._free(e))),e}}},6640:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),a=n(2235),o=n(2850),i=n(9544);let s;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(e){const t=await fetch(e),n=await t.arrayBuffer();return(0,i.createSessionAllocate)(new Uint8Array(n))}async loadModel(e,t){if(s||(await(0,i.initializeRuntime)(a.env),s=!0),"string"==typeof e)if("undefined"!=typeof process&&process.versions&&process.versions.node){const n=await(0,o.promisify)(r.readFile)(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(n,t)}else{const n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSessionFinalize)(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(e,t)}async dispose(){return(0,i.releaseSession)(this.sessionId)}async run(e,t,n){const r=[],o=[];Object.entries(e).forEach((e=>{const t=e[0],n=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw new Error(`invalid input '${t}'`);r.push(n),o.push(a)}));const s=[];Object.entries(t).forEach((e=>{const t=e[0],n=this.outputNames.indexOf(t);if(-1===n)throw new Error(`invalid output '${t}'`);s.push(n)}));const u=await(0,i.run)(this.sessionId,o,r.map((e=>[e.type,e.dims,e.data])),s,n),l={};for(let e=0;e<u.length;e++)l[this.outputNames[s[e]]]=new a.Tensor(u[e][0],u[e][2],u[e][1]);return l}startProfiling(){}endProfiling(){(0,i.endProfiling)(this.sessionId)}}},7622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(263),a=n(1497);t.setSessionOptions=e=>{var t,n,o,i;const s=(0,r.getInstance)();let u=0;const l=[],c=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(c);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=c.graphOptimizationLevel)&&void 0!==t?t:"all"),d=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=c.executionMode)&&void 0!==n?n:"sequential"),p="string"==typeof c.logId?(0,a.allocWasmString)(c.logId,l):0,f=null!==(o=c.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log serverity level is not valid: ${f}`);const h=null!==(i=c.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);const g="string"==typeof c.optimizedModelFilePath?(0,a.allocWasmString)(c.optimizedModelFilePath,l):0;return u=s._OrtCreateSessionOptions(e,!!c.enableCpuMemArena,!!c.enableMemPattern,d,!!c.enableProfiling,0,p,f,h,g),0===u&&(0,a.checkLastError)("Can't create session options."),c.executionProviders&&((e,t,n)=>{for(const o of t){let t="string"==typeof o?o:o.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)("deviceType",n),i=(0,a.allocWasmString)(t.deviceType,n);0!==(0,r.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can't set a session config entry: 'deviceType' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)("powerPreference",n),i=(0,a.allocWasmString)(t.powerPreference,n);0!==(0,r.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,n);0!==(0,r.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can't append execution provider: ${t}.`)}})(u,c.executionProviders,l),void 0!==c.extra&&(0,a.iterateExtraOptions)(c.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);0!==s._OrtAddSessionConfigEntry(u,n,r)&&(0,a.checkLastError)(`Can't set a session config entry: ${e} - ${t}.`)})),[u,l]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),l.forEach((e=>s._free(e))),e}}},7917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},1259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const r=n(7675),a=n(7918),o=n(7622),i=n(7917),s=n(263),u=n(1497);t.initRuntime=async e=>{var t,n;t=e.wasm.numThreads,n=(0,i.logLevelStringToEnum)(e.logLevel),0!==(0,s.getInstance)()._OrtInit(t,n)&&(0,u.checkLastError)("Can't initialize onnxruntime."),await(0,r.init)((0,s.getInstance)(),e)};const l=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,a=0,i=[];const c=[],d=[];try{[a,i]=(0,o.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],a),0===r&&(0,u.checkLastError)("Can't create a session.");const[p,f]=(e=>{const t=(0,s.getInstance)(),n=t.stackSave();try{const n=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,n,n+4)&&(0,u.checkLastError)("Can't get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(n)}})(r),h=[],g=[];for(let e=0;e<p;e++){const t=n._OrtGetInputName(r,e);0===t&&(0,u.checkLastError)("Can't get an input name."),c.push(t),h.push(n.UTF8ToString(t))}for(let e=0;e<f;e++){const t=n._OrtGetOutputName(r,e);0===t&&(0,u.checkLastError)("Can't get an output name."),d.push(t),g.push(n.UTF8ToString(t))}return l.set(r,[r,c,d]),[r,h,g]}catch(e){throw c.forEach((e=>n._OrtFree(e))),d.forEach((e=>n._OrtFree(e))),0!==r&&n._OrtReleaseSession(r),e}finally{n._free(e[0]),0!==a&&n._OrtReleaseSessionOptions(a),i.forEach((e=>n._free(e)))}},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=l.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);const[r,a,o]=n;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(r),l.delete(e)},t.run=async(e,t,n,r,o)=>{const c=(0,s.getInstance)(),d=l.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);const[p,f,h]=d,g=t.length,m=r.length;let b=0,v=[];const y=[],w=[];try{[b,v]=(0,a.setRunOptions)(o);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let o,s;if(Array.isArray(a)){s=4*a.length,o=c._malloc(s),w.push(o);let e=o/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);c.HEAPU32[e++]=(0,u.allocWasmString)(a[t],w)}}else s=a.byteLength,o=c._malloc(s),w.push(o),c.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,s),o);const l=c.stackSave(),d=c.stackAlloc(4*r.length);try{let n=d/4;r.forEach((e=>c.HEAP32[n++]=e));const a=c._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),o,s,d,r.length);0===a&&(0,u.checkLastError)(`Can't create tensor for input[${e}].`),y.push(a)}finally{c.stackRestore(l)}}const e=c.stackSave(),s=c.stackAlloc(4*g),l=c.stackAlloc(4*g),d=c.stackAlloc(4*m),$=c.stackAlloc(4*m);try{let e=s/4,n=l/4,a=d/4,o=$/4;for(let r=0;r<g;r++)c.HEAPU32[e++]=y[r],c.HEAPU32[n++]=f[t[r]];for(let e=0;e<m;e++)c.HEAPU32[a++]=0,c.HEAPU32[o++]=h[r[e]];let v=c._OrtRun(p,l,s,g,$,m,d,b);const w=c.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const _=[];0!==v&&(0,u.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=c.HEAPU32[d/4+e],n=c.stackSave(),r=c.stackAlloc(16);let a,o=0;try{v=c._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==v&&(0,u.checkLastError)(`Can't access output tensor data on index ${e}.`);let n=r/4;const s=c.HEAPU32[n++];o=c.HEAPU32[n++];const l=c.HEAPU32[n++],d=c.HEAPU32[n++],p=[];for(let e=0;e<d;e++)p.push(c.HEAPU32[l/4+e]);c._OrtFree(l);const f=0===p.length?1:p.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(s),"string"===a){const e=[];let t=o/4;for(let n=0;n<f;n++){const r=c.HEAPU32[t++],a=n===f-1?void 0:c.HEAPU32[t]-r;e.push(c.UTF8ToString(r,a))}_.push([a,p,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(f);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(c.HEAPU8.subarray(o,o+e.byteLength)),_.push([a,p,e])}}finally{c.stackRestore(n),"string"===a&&o&&c._free(o),c._OrtReleaseTensor(t)}}return _}finally{c.stackRestore(e)}}finally{y.forEach((e=>c._OrtReleaseTensor(e))),w.forEach((e=>c._free(e))),0!==b&&c._OrtReleaseRunOptions(b),v.forEach((e=>c._free(e)))}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=l.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);0===a&&(0,u.checkLastError)("Can't get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0,o(n(6449));const i=n(932),s=i;let u,l=!1,c=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(c)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(d)throw new Error("previous call to 'initializeWebAssembly()' failed.");c=!0;const t=e.initTimeout,n=e.numThreads,r=e.simd,a=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),o=r&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),p=e.wasmPaths,f="string"==typeof p?p:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(o,a),g="object"==typeof p?p[h]:void 0;let m=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{m=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{(a?s:i)({locateFile:(e,t)=>e.endsWith(".wasm")?g||(null!=f?f:t)+h:t+e}).then((t=>{c=!1,l=!0,u=t,e()}),(e=>{c=!1,d=!0,t(e)}))}))),await Promise.race(b),m)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&u)return u;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||c||d||(c=!0,null===(e=u.PThread)||void 0===e||e.terminateAllThreads(),u=void 0,c=!1,l=!1,d=!0)}},1497:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can't handle extra config type: "+typeof o);a(i,o?"1":"0")}}))},t.checkLastError=e=>{const t=(0,r.getInstance)(),n=t.stackSave();try{const n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);const r=t.HEAP32[n/4],a=t.HEAPU32[n/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(n)}}},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,r,a;t||(t=void 0!==e?e:{}),t.ready=new Promise(((e,t)=>{r=e,a=t}));var o,i,s,u=Object.assign({},t),l="./this.program",c=(e,t)=>{throw t},d="object"==typeof window,p="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var g=n(1384),m=n(908);h=p?m.dirname(h)+"/":__dirname+"/",o=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),g.readFileSync(e,t?void 0:"utf8")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),g.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!t.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),c=(e,t)=>{throw process.exitCode=e,t},t.inspect=()=>"[Emscripten Module object]"}else(d||p)&&(p?h=self.location.href:"undefined"!=typeof document&&document.currentScript&&(h=document.currentScript.src),_scriptDir&&(h=_scriptDir),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},p&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var b,v=t.print||console.log.bind(console),y=t.printErr||console.warn.bind(console);Object.assign(t,u),u=null,t.thisProgram&&(l=t.thisProgram),t.quit&&(c=t.quit),t.wasmBinary&&(b=t.wasmBinary);var w=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&j("no native wasm support detected");var $,_,S,A,E,O=!1;function P(){var e=$.buffer;t.HEAP8=_=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=A=new Int32Array(e),t.HEAPU8=S=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=E=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var C=[],T=[],I=[];function x(){var e=t.preRun.shift();C.unshift(e)}var R,k=0,M=null,D=null;function j(e){throw t.onAbort&&t.onAbort(e),y(e="Aborted("+e+")"),O=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function B(e){return e.startsWith("data:application/octet-stream;base64,")}if(!B(R="ort-wasm.wasm")){var G=R;R=t.locateFile?t.locateFile(G,h):h+G}function U(e){try{if(e==R&&b)return new Uint8Array(b);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){j(e)}}function z(e,t,n){return function(e){if(!b&&(d||p)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>U(e)));if(i)return new Promise(((t,n)=>{i(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>U(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{y("failed to asynchronously prepare wasm: "+e),j(e)}))}function L(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function W(e){for(;0<e.length;)e.shift()(t)}function H(e){this.ra=e-24,this.wa=function(e){E[this.ra+4>>2>>>0]=e},this.va=function(e){E[this.ra+8>>2>>>0]=e},this.ta=function(e,t){this.ua(),this.wa(e),this.va(t)},this.ua=function(){E[this.ra+16>>2>>>0]=0}}var F="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function N(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&F)return F.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function K(e,t){return(e>>>=0)?N(S,e,t):""}function V(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function q(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function Y(e,t,n){return q(e,S,t,n)}function X(e){return 0==e%4&&(0!=e%100||0==e%400)}var Q=[0,31,60,91,121,152,182,213,244,274,305,335],J=[0,31,59,90,120,151,181,212,243,273,304,334];function Z(e){return(X(e.getFullYear())?Q:J)[e.getMonth()]+e.getDate()-1}function ee(e){var t=V(e)+1,n=de(t);return n&&Y(e,n,t),n}var te={};function ne(){if(!re){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"};for(e in te)void 0===te[e]?delete t[e]:t[e]=te[e];var n=[];for(e in t)n.push(e+"="+t[e]);re=n}return re}var re,ae=[null,[],[]];function oe(e){return(oe=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(f)try{var e=n(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}j("initRandomDevice")}())(e)}var ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.na;for(e=new Date(new Date(e.oa+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(X(e.getFullYear())?ie:se)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var l=A[r+40>>2>>>0];for(var c in r={za:A[r>>2>>>0],ya:A[r+4>>2>>>0],pa:A[r+8>>2>>>0],sa:A[r+12>>2>>>0],qa:A[r+16>>2>>>0],oa:A[r+20>>2>>>0],ja:A[r+24>>2>>>0],na:A[r+28>>2>>>0],Ba:A[r+32>>2>>>0],xa:A[r+36>>2>>>0],Aa:l?K(l):""},n=K(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(c,"g"),l[c]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(c in l={"%a":function(e){return d[e.ja].substring(0,3)},"%A":function(e){return d[e.ja]},"%b":function(e){return p[e.qa].substring(0,3)},"%B":function(e){return p[e.qa]},"%C":function(e){return o((e.oa+1900)/100|0,2)},"%d":function(e){return o(e.sa,2)},"%e":function(e){return a(e.sa,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.pa,2)},"%I":function(e){return 0==(e=e.pa)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.qa-1;t+=(X(e.oa+1900)?ie:se)[n++]);return o(e.sa+t,3)},"%m":function(e){return o(e.qa+1,2)},"%M":function(e){return o(e.ya,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.pa&&12>e.pa?"AM":"PM"},"%S":function(e){return o(e.za,2)},"%t":function(){return"\t"},"%u":function(e){return e.ja||7},"%U":function(e){return o(Math.floor((e.na+7-e.ja)/7),2)},"%V":function(e){var t=Math.floor((e.na+7-(e.ja+6)%7)/7);if(2>=(e.ja+371-e.na-2)%7&&t++,t)53==t&&(4==(n=(e.ja+371-e.na)%7)||3==n&&X(e.oa)||(t=1));else{t=52;var n=(e.ja+7-e.na-1)%7;(4==n||5==n&&X(e.oa%400-1))&&t++}return o(t,2)},"%w":function(e){return e.ja},"%W":function(e){return o(Math.floor((e.na+7-(e.ja+6)%7)/7),2)},"%y":function(e){return(e.oa+1900).toString().substring(2)},"%Y":function(e){return e.oa+1900},"%z":function(e){var t=0<=(e=e.xa);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Aa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),l)n.includes(c)&&(n=n.replace(new RegExp(c,"g"),l[c](r)));return c=function(e){var t=Array(V(e)+1);return q(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),c.length>t?0:(_.set(c,e>>>0),c.length-1)}var le={a:function(e,t,n){throw new H(e).ta(t,n),e},l:function(){j("To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html")},f:function(){return 0},K:function(){},u:function(){},x:function(){},M:function(){return 0},I:function(){},D:function(){},H:function(){},j:function(){},w:function(){},s:function(){},J:function(){},t:function(){},k:function(){return!0},A:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*A[e+4>>>2])),A[t>>2>>>0]=e.getUTCSeconds(),A[t+4>>2>>>0]=e.getUTCMinutes(),A[t+8>>2>>>0]=e.getUTCHours(),A[t+12>>2>>>0]=e.getUTCDate(),A[t+16>>2>>>0]=e.getUTCMonth(),A[t+20>>2>>>0]=e.getUTCFullYear()-1900,A[t+24>>2>>>0]=e.getUTCDay(),A[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},B:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*A[e+4>>>2])),A[t>>2>>>0]=e.getSeconds(),A[t+4>>2>>>0]=e.getMinutes(),A[t+8>>2>>>0]=e.getHours(),A[t+12>>2>>>0]=e.getDate(),A[t+16>>2>>>0]=e.getMonth(),A[t+20>>2>>>0]=e.getFullYear()-1900,A[t+24>>2>>>0]=e.getDay(),A[t+28>>2>>>0]=0|Z(e),A[t+36>>2>>>0]=-60*e.getTimezoneOffset();var n=new Date(e.getFullYear(),6,1).getTimezoneOffset(),r=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[t+32>>2>>>0]=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n))},C:function(e){var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),n=A[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>n?A[e+32>>2>>>0]=Number(a!=o&&i==r):0<n!=(i==r)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<n?i:a)-r))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=0|Z(t),A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),t.getTime()/1e3|0},y:function(){return-52},z:function(){},q:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),A[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=ee(e),t=ee(t),s<a?(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t):(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e)},d:function(){j("")},G:function(){j("To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html")},g:function(){return Date.now()},r:function(){return 4294901760},b:f?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),L:function(e,t,n){S.copyWithin(e>>>0,t>>>0,t+n>>>0)},p:function(e){var t=S.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math,o=a.min;r=Math.max(e,r),r+=(65536-r%65536)%65536;e:{var i=$.buffer;try{$.grow(o.call(a,4294901760,r)-i.byteLength+65535>>>16),P();var s=1;break e}catch(e){}s=void 0}if(s)return!0}return!1},E:function(e,t){var n=0;return ne().forEach((function(r,a){var o=t+n;for(a=E[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)_[a++>>0>>>0]=r.charCodeAt(o);_[a>>0>>>0]=0,n+=r.length+1})),0},F:function(e,t){var n=ne();E[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),E[t>>2>>>0]=r,0},m:function(e){w||(t.onExit&&t.onExit(e),O=!0),c(e,new L(e))},e:function(){return 52},i:function(){return 52},n:function(){return 70},h:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=E[t>>2>>>0],s=E[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=S[i+u>>>0],c=ae[e];0===l||10===l?((1===e?v:y)(N(c,0)),c.length=0):c.push(l)}a+=s}return E[r>>2>>>0]=a,0},o:function(e,t){return oe(S.subarray(e>>>0,e+t>>>0)),0},v:ue,c:function(e,t,n,r){return ue(e,t,n,r)}};!function(){function e(e){if(e=e.exports,t.asm=e,$=t.asm.N,P(),T.unshift(t.asm.O),k--,t.monitorRunDependencies&&t.monitorRunDependencies(k),0==k&&(null!==M&&(clearInterval(M),M=null),D)){var n=D;D=null,n()}return e}var n={a:le};if(k++,t.monitorRunDependencies&&t.monitorRunDependencies(k),t.instantiateWasm)try{return t.instantiateWasm(n,e)}catch(e){y("Module.instantiateWasm callback failed with error: "+e),a(e)}(function(e,t){var n=R;return b||"function"!=typeof WebAssembly.instantiateStreaming||B(n)||n.startsWith("file://")||f||"function"!=typeof fetch?z(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return y("wasm streaming compile failed: "+r),y("falling back to ArrayBuffer instantiation"),z(n,e,t)}))))})(n,(function(t){e(t.instance)})).catch(a)}(),t._OrtInit=function(){return(t._OrtInit=t.asm.P).apply(null,arguments)},t._OrtGetLastError=function(){return(t._OrtGetLastError=t.asm.Q).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.R).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.S).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.T).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.U).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.V).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.W).apply(null,arguments)},t._OrtGetInputOutputCount=function(){return(t._OrtGetInputOutputCount=t.asm.X).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm.Y).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.Z).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm._).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.$).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.aa).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.ba).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ca).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.da).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ea).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.fa).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ga).apply(null,arguments)};var ce,de=t._malloc=function(){return(de=t._malloc=t.asm.ha).apply(null,arguments)};function pe(){return(pe=t.asm.ka).apply(null,arguments)}function fe(){return(fe=t.asm.la).apply(null,arguments)}function he(){return(he=t.asm.ma).apply(null,arguments)}function ge(){function e(){if(!ce&&(ce=!0,t.calledRun=!0,!O)){if(W(T),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();I.unshift(e)}W(I)}}if(!(0<k)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)x();W(C),0<k||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t._free=function(){return(t._free=t.asm.ia).apply(null,arguments)},t.stackAlloc=he,t.stackSave=pe,t.stackRestore=fe,t.UTF8ToString=K,t.stringToUTF8=Y,t.lengthBytesUTF8=V,D=function e(){ce||ge(),ce||(D=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return ge(),e.ready});e.exports=r},760:()=>{},1384:()=>{},908:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},685:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.registerBackend=void 0;const n={},r=[];t.registerBackend=(e,t,a)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createSessionHandler)throw new TypeError("not a valid backend");{const o=n[e];if(void 0===o)n[e]={backend:t,priority:a};else{if(o.priority>a)return;if(o.priority===a&&o.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${a}`)}if(a>=0){const t=r.indexOf(e);-1!==t&&r.splice(t,1);for(let t=0;t<r.length;t++)if(n[r[t]].priority<=a)return void r.splice(t,0,e);r.push(e)}}},t.resolveBackend=async e=>{const t=0===e.length?r:e,a=[];for(const e of t){const t=n[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(r){n||a.push({name:e,err:r}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${a.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)}},4798:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.registerBackend=void 0;var r=n(685);Object.defineProperty(t,"registerBackend",{enumerable:!0,get:function(){return r.registerBackend}})},3121:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.env=void 0;const r=n(9104);let a="warning";t.env={wasm:{},webgl:{},webgpu:{},versions:{common:r.version},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);a=e}},get logLevel(){return a}},Object.defineProperty(t.env,"logLevel",{enumerable:!0})},2457:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.env=void 0;const r=n(3121);t.env=r.env},2235:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),a(n(4798),t),a(n(2457),t),a(n(3974),t),a(n(963),t),a(n(7852),t)},8036:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InferenceSession=void 0;const r=n(685),a=n(963);class o{constructor(e){this.handler=e}async run(e,t,n){const r={};let o={};if("object"!=typeof e||null===e||e instanceof a.Tensor||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof a.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)o=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let e=!1;const s=Object.getOwnPropertyNames(t);for(const n of this.outputNames)if(-1!==s.indexOf(n)){const o=t[n];(null===o||o instanceof a.Tensor)&&(e=!0,i=!1,r[n]=o)}if(e){if("object"==typeof n&&null!==n)o=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(const e of this.outputNames)r[e]=null;const s=await this.handler.run(e,r,o),u={};for(const e in s)Object.hasOwnProperty.call(s,e)&&(u[e]=new a.Tensor(s[e].type,s[e].data,s[e].dims));return u}async release(){return this.handler.dispose()}static async create(e,t,n,a){let i,s={};if("string"==typeof e){if(i=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const r=e;let o=0,u=e.byteLength;if("object"==typeof t&&null!==t)s=t;else if("number"==typeof t){if(o=t,!Number.isSafeInteger(o))throw new RangeError("'byteOffset' must be an integer.");if(o<0||o>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(u=e.byteLength-o,"number"==typeof n){if(u=n,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||o+u>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-o}].`);if("object"==typeof a&&null!==a)s=a;else if(void 0!==a)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");i=new Uint8Array(r,o,u)}}const u=(s.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await(0,r.resolveBackend)(u),c=await l.createSessionHandler(i,s);return new o(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}t.InferenceSession=o},3974:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InferenceSession=void 0;const r=n(8036);t.InferenceSession=r.InferenceSession},7852:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},2350:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tensorToImageData=t.tensorToDataURL=void 0,t.tensorToDataURL=(e,t)=>{const n=document.createElement("canvas");n.width=e.dims[3],n.height=e.dims[2];const r=n.getContext("2d");if(null!=r){let a,o;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],o=e.dims[3]):(a=e.dims[3],o=e.dims[2]);const i=void 0!==t?.format?t.format:"RGB",s=t?.norm;let u,l;void 0===s||void 0===s.mean?u=[255,255,255,255]:"number"==typeof s.mean?u=[s.mean,s.mean,s.mean,s.mean]:(u=[s.mean[0],s.mean[1],s.mean[2],0],void 0!==s.mean[3]&&(u[3]=s.mean[3])),void 0===s||void 0===s.bias?l=[0,0,0,0]:"number"==typeof s.bias?l=[s.bias,s.bias,s.bias,s.bias]:(l=[s.bias[0],s.bias[1],s.bias[2],0],void 0!==s.bias[3]&&(l[3]=s.bias[3]));const c=o*a;let d=0,p=c,f=2*c,h=-1;"RGBA"===i?(d=0,p=c,f=2*c,h=3*c):"RGB"===i?(d=0,p=c,f=2*c):"RBG"===i&&(d=0,f=c,p=2*c);for(let t=0;t<o;t++)for(let n=0;n<a;n++){const a=(e.data[d++]-l[0])*u[0],o=(e.data[p++]-l[1])*u[1],i=(e.data[f++]-l[2])*u[2],s=-1===h?255:(e.data[h++]-l[3])*u[3];r.fillStyle="rgba("+a+","+o+","+i+","+s+")",r.fillRect(n,t,1,1)}return n.toDataURL()}throw new Error("Can not access image data")},t.tensorToImageData=(e,t)=>{const n=document.createElement("canvas").getContext("2d");let r;if(null==n)throw new Error("Can not access image data");{let a,o,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],o=e.dims[1],i=e.dims[3]):(a=e.dims[3],o=e.dims[2],i=e.dims[1]);const s=void 0!==t&&void 0!==t.format?t.format:"RGB",u=t?.norm;let l,c;void 0===u||void 0===u.mean?l=[255,255,255,255]:"number"==typeof u.mean?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],255],void 0!==u.mean[3]&&(l[3]=u.mean[3])),void 0===u||void 0===u.bias?c=[0,0,0,0]:"number"==typeof u.bias?c=[u.bias,u.bias,u.bias,u.bias]:(c=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(c[3]=u.bias[3]));const d=o*a;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");const p=4;let f=0,h=1,g=2,m=3,b=0,v=d,y=2*d,w=-1;"RGBA"===s?(b=0,v=d,y=2*d,w=3*d):"RGB"===s?(b=0,v=d,y=2*d):"RBG"===s&&(b=0,y=d,v=2*d),r=n.createImageData(a,o);for(let t=0;t<o*a;f+=p,h+=p,g+=p,m+=p,t++)r.data[f]=(e.data[b++]-c[0])*l[0],r.data[h]=(e.data[v++]-c[1])*l[1],r.data[g]=(e.data[y++]-c[2])*l[2],r.data[m]=-1===w?255:(e.data[w++]-c[3])*l[3]}return r}},4866:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tensorFromImage=t.bufferToTensor=void 0;const r=n(963);t.bufferToTensor=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:a}=t,o=t.norm??{mean:255,bias:0};let i,s;i="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],s="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];const u=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",c=n*a,d="RGBA"===l?new Float32Array(4*c):new Float32Array(3*c);let p=4,f=0,h=1,g=2,m=3,b=0,v=c,y=2*c,w=-1;"RGB"===u&&(p=3,f=0,h=1,g=2,m=-1),"RGBA"===l?w=3*c:"RBG"===l?(b=0,y=c,v=2*c):"BGR"===l&&(y=0,v=c,b=2*c);for(let t=0;t<c;t++,f+=p,g+=p,h+=p,m+=p)d[b++]=(e[f]+s[0])/i[0],d[v++]=(e[h]+s[1])/i[1],d[y++]=(e[g]+s[2])/i[2],-1!==w&&-1!==m&&(d[w++]=(e[m]+s[3])/i[3]);return"RGBA"===l?new r.Tensor("float32",d,[1,4,n,a]):new r.Tensor("float32",d,[1,3,n,a])},t.tensorFromImage=async(e,n)=>{const r="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,a="undefined"!=typeof ImageData&&e instanceof ImageData,o="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e;let s,u=n??{};if(r){const t=document.createElement("canvas");t.width=e.width,t.height=e.height;const r=t.getContext("2d");if(null==r)throw new Error("Can not access image data");{let t=e.height,a=e.width;if(void 0!==n&&void 0!==n.resizedHeight&&void 0!==n.resizedWidth&&(t=n.resizedHeight,a=n.resizedWidth),void 0!==n){if(u=n,void 0!==n.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");u.tensorFormat="RGBA",u.height=t,u.width=a}else u.tensorFormat="RGBA",u.height=t,u.width=a;r.drawImage(e,0,0),s=r.getImageData(0,0,a,t).data}}else{if(!a){if(o){if(void 0===n)throw new Error("Please provide image config with format for Imagebitmap");const r=document.createElement("canvas").getContext("2d");if(null!=r){const n=e.height,a=e.width;return r.drawImage(e,0,0,a,n),s=r.getImageData(0,0,a,n).data,u.height=n,u.width=a,(0,t.bufferToTensor)(s,u)}throw new Error("Can not access image data")}if(i)return new Promise(((n,r)=>{const a=document.createElement("canvas"),o=a.getContext("2d");if(!e||!o)return r();const i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{a.width=i.width,a.height=i.height,o.drawImage(i,0,0,a.width,a.height);const e=o.getImageData(0,0,a.width,a.height);u.height=a.height,u.width=a.width,n((0,t.bufferToTensor)(e.data,u))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let t,r;if(void 0!==n&&void 0!==n.resizedWidth&&void 0!==n.resizedHeight?(t=n.resizedHeight,r=n.resizedWidth):(t=e.height,r=e.width),void 0!==n&&(u=n),u.format="RGBA",u.height=t,u.width=r,void 0!==n){const n=document.createElement("canvas");n.width=r,n.height=t;const a=n.getContext("2d");if(null==a)throw new Error("Can not access image data");a.putImageData(e,0,0),s=a.getImageData(0,0,r,t).data}else s=e.data}}if(void 0!==s)return(0,t.bufferToTensor)(s,u);throw new Error("Input data provided is not supported - aborted tensor creation")}},5957:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const r=n(2350),a=n(4866),o=n(106),i=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),s=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let u=!1;t.Tensor=class{constructor(e,t,n){let r,a,l;if((()=>{if(!u){u=!0;const e="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;e&&(i.set("int64",BigInt64Array),s.set(BigInt64Array,"int64")),t&&(i.set("uint64",BigUint64Array),s.set(BigUint64Array,"uint64"))}})(),"string"==typeof e)if(r=e,l=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{const n=i.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e)throw new TypeError(`Unsupported tensor type: ${e}.`);a=n.from(t)}else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);a=t}}else if(l=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",a=Uint8Array.from(e)}}else{const t=s.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,a=e}if(void 0===l)l=[a.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");const c=(0,o.calculateSize)(l);if(c!==a.length)throw new Error(`Tensor's size(${c}) does not match data length(${a.length}).`);this.dims=l,this.type=r,this.data=a,this.size=c}static async fromImage(e,t){return(0,a.tensorFromImage)(e,t)}toDataURL(e){return(0,r.tensorToDataURL)(this,e)}toImageData(e){return(0,r.tensorToImageData)(this,e)}reshape(e){return(0,o.tensorReshape)(this,e)}}},106:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tensorReshape=t.calculateSize=void 0;const r=n(963);t.calculateSize=e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},t.tensorReshape=(e,t)=>new r.Tensor(e.type,e.data,t)},963:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const r=n(5957);t.Tensor=r.Tensor},9104:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.version=void 0,t.version="1.16.0-dev.20230704-d540c7da0f"}},t={},function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}(1057);var e,t}));
//# sourceMappingURL=ort.wasm-core.min.js.map